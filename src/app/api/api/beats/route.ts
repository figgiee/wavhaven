import { NextRequest, NextResponse } from 'next/server';\n\n// Example data structure - replace with your actual Beat type\ninterface Beat {\n  id: string | number;\n  title: string;\n  producerName: string;\n  price: number;\n  // Add other necessary fields\n}\n\n// Example function to fetch beats (replace with your actual data fetching logic)\nasync function getBeatsFromDatabase(page: number, limit: number, searchTerm?: string, sortBy?: string, genres?: string[], minBpm?: number, maxBpm?: number, key?: string, tags?: string[]): Promise<{ beats: Beat[], totalCount: number }> {\n  // --- Placeholder Logic --- \n  // In a real application, you would fetch this data from your database (e.g., Supabase, PostgreSQL)\n  // based on the provided filters, sorting, and pagination.\n  console.log('API received params:', { page, limit, searchTerm, sortBy, genres, minBpm, maxBpm, key, tags });\n\n  const allBeats: Beat[] = [\n    // Add some sample beat data if needed for initial testing\n    { id: 1, title: 'Sunset Drive', producerName: 'Synthwave King', price: 29.99 },\n    { id: 2, title: 'Midnight Lo-fi', producerName: 'Chill Beats Co.', price: 19.99 },\n    // ... more sample beats\n  ];\n\n  // Basic filtering/pagination simulation (replace with actual DB query)\n  const filteredBeats = allBeats; // Apply actual filtering based on params here\n  const totalCount = filteredBeats.length;\n  const startIndex = (page - 1) * limit;\n  const endIndex = startIndex + limit;\n  const paginatedBeats = filteredBeats.slice(startIndex, endIndex);\n  // --- End Placeholder Logic ---\n\n  return { beats: paginatedBeats, totalCount };\n}\n\nexport async function GET(request: NextRequest) {\n  const searchParams = request.nextUrl.searchParams;\n\n  // --- Extract and Validate Parameters --- \n  const page = parseInt(searchParams.get('page') || '1', 10);\n  const limit = parseInt(searchParams.get('limit') || '10', 10);\ // Default limit\n  const searchTerm = searchParams.get('term') || undefined;\n  const sortBy = searchParams.get('sortBy') || 'relevance'; // Default sort\n  const genres = searchParams.get('genres')?.split(',') || undefined;\n  const minBpmStr = searchParams.get('minBpm');\n  const maxBpmStr = searchParams.get('maxBpm');\n  const key = searchParams.get('key') || undefined;\n  const tags = searchParams.get('tags')?.split(',') || undefined;\n\n  const minBpm = minBpmStr ? parseInt(minBpmStr, 10) : undefined;\n  const maxBpm = maxBpmStr ? parseInt(maxBpmStr, 10) : undefined;\n\n  // Basic validation (you might want more robust validation)\n  if (isNaN(page) || page < 1) {\n    return NextResponse.json({ error: 'Invalid page number' }, { status: 400 });\n  }\n  if (isNaN(limit) || limit < 1 || limit > 100) { // Add a max limit\n    return NextResponse.json({ error: 'Invalid limit value' }, { status: 400 });\n  }\n  if (minBpm !== undefined && isNaN(minBpm)) {\n      return NextResponse.json({ error: 'Invalid minBpm value' }, { status: 400 });\n  }\n  if (maxBpm !== undefined && isNaN(maxBpm)) {\n      return NextResponse.json({ error: 'Invalid maxBpm value' }, { status: 400 });\n  }\n  if (minBpm !== undefined && maxBpm !== undefined && minBpm > maxBpm) {\n       return NextResponse.json({ error: 'minBpm cannot be greater than maxBpm' }, { status: 400 });\n  }\n  // Add validation for other params (sortBy, genres, key, tags) if necessary\n\n  try {\n    // --- Fetch Data --- \n    const { beats, totalCount } = await getBeatsFromDatabase(\n        page,\n        limit,\n        searchTerm,\n        sortBy,\n        genres,\n        minBpm,\n        maxBpm,\n        key,\n        tags\n    );\n\n    // --- Return Response --- \n    return NextResponse.json({ \n        beats,\n        totalCount,\n        currentPage: page,\n        totalPages: Math.ceil(totalCount / limit)\n    });\n\n  } catch (error) {\n    console.error('Error fetching beats in API route:', error);\n    // Don't expose detailed internal errors to the client\n    return NextResponse.json({ error: 'Failed to fetch beats. Please try again later.' }, { status: 500 });\n  }\n}\n 